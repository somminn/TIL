## 섹션 6. 컬렉션 프레임워크 - List

### 1. 리스트 추상화1 - 인터페이스 도입
`순서가 있고, 중복을 허용하는 자료 구조를 리스트(List)라 한다.`

MyArrayList 와 MyLinkedList 에서 같은 기능을 제공하는 메서드를 뽑아 MyList 라는 인터페이스로 만들어보자.
![MyList](https://github.com/somminn/TIL/blob/main/image/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202025-03-19%20%EC%98%A4%ED%9B%84%207.56.21.png?raw=true)

### 2. 리스트 추상화2 - 의존관계 주입

#### 구체적인 클래스에 의존
아래 코드는 BatchProcessor 가 구체적인 클래스인 MyArrayList 에 의존한다고 표현할 수 있다.   
구체적인 클래스에 직접 의존하면 프레임워크 변경 시 BatchProcessor 코드도 수정해야 한다.
```java
public class BatchProcessor {
    private final MyArrayList<Integer> list = new MyArrayList<>();
}
```

#### 추상적인 MyList 에 의존
구체적인 클래스에 의존하는 대신 추상적인 MyList 인터페이스에 의존하면 코드를 수정하지 않아도 된다.
```java
public class BatchProcessor {
      private final MyList<Integer> list;
      public BatchProcessor(MyList<Integer> list) {
          this.list = list;
}
```
#### 의존관계 주입 : DI(Dependency Injection)
`의존관계 주입이란 외부에서 의존관계가 결정되어서 인스턴스에 들어오는 것!`   
BatchProcessor 를 생성하는 시점에 생성자를 통해 원하는 리스트 전략(알고리즘)을 선택해서 전달하면 된다.   
생성자를 통해 런타임 의존관계를 주입하는 것을 생성자 의존관계 주입 또는 줄여서 생성자 주입이라 한다.
```java
main() {
    new BatchProcessor(new MyArrayList()); //MyArrayList를 사용하고 싶을 때 
    new BatchProcessor(new MyLinkedList()); //MyLinkedList를 사용하고 싶을 때
}
```


### 3. 리스트 추상화3 - 컴파일 타임, 런타임 의존관계

#### 의존관계 종류
- 컴파일 타임 의존관계 : 코드 컴파일 시점
- 런타임 의존관계 : 프로그램 실행 시점  

클라이언트 클래스는 컴파일 타임에 추상적인 것에 의존하고, 런타임에 구체적인 의존 관계 주입을 통해 구현체를 주입받아 사용함으로써 구현을 자유롭게 확장할 수 있다. 
   
#### 컴파일 타임 의존관계
`컴파일 타임 의존관계는 실행하지 않은 소스 코드에서 자바 컴파일러가 정적으로 분석이 가능한 의존 관계이다.`

![컴파일 타임 의존관계](https://github.com/user-attachments/assets/bd623c11-f3b5-4ac4-9e79-cc67015616f5)
```java
private final MyList<Integer> list; 
```
BatchProcessor 가 MyList 인터페이스를 의존하는 것이 컴파일 타임 의존이다. (추상적 의존)


#### 런타임 의존관계
`런타임 의존관계는 프로그램 실행 시점에 인스턴스 간에 형성되는 의존 관계이다.`

![런타임 의존관계](https://github.com/user-attachments/assets/c431937d-a57c-4a7f-b84d-3a62c2e00793)
```java
MyArrayList<Integer> list = new MyArrayList<>();
BatchProcessor processor = new BatchProcessor(list);
```
BatchProcessor 에 생성자를 주입하는 것이 런타임 의존이다.

#### 전략 패턴(Strategy Pattern)
> 위 코드가 바로 전략 패턴을 사용한 코드이다. `MyList` 인터페이스가 바로 전략을 정의하는 인터페이스가 되고, 각각의 구현체인 `MyArrayList`, `MyLinkedList` 가 전략의 구체적인 구현이 된다. 그리고 전략을 클라이언트 코드( `BatchProcessor` )의 변경없이 손쉽게 교체할 수 있다.



### 4. 직접 구현한 리스트의 성능 비교
#### 성능 비교 표
|    기능     |배열리스트|연결리스트    |
|:---------:|:--:|:--:|
| 앞에 추가(삭제) |O(n)|O(1)|
| 평균 추가(삭제) |O(n)|O(n)|
| 뒤에 추가(삭제) |O(1)|O(n)|
|  인덱스 조회   |O(1)|O(n)|
|    검색     |O(n)|O(n)|

#### 추가, 삭제
- `배열 리스트`는 인덱스를 통해 추가나 삭제할 위치를 O(1)로 빠르게 찾지만, 추가나 삭제 이후에 데이터를 한칸씩 밀어야 한다. 이 부분이 O(n)으로 오래 걸린다.
- `연결 리스트`는 인덱스를 통해 추가나 삭제할 위치를 O(n)으로 느리게 찾지만, 실제 데이터의 추가는 간단한 참조 변경으로 빠르게 O(1)로 수행된다.

#### 앞에 추가(삭제)
- 배열 리스트: 추가나 삭제할 위치는 찾는데 O(1), 데이터를 한칸씩 이동 O(n) -> O(n) 
- 연결 리스트: 추가나 삭제할 위치는 찾는데 O(1), 노드를 변경하는데 O(1) -> O(1)

#### 평균 추가(삭제)
- 배열 리스트: 추가나 삭제할 위치는 찾는데 O(1), 인덱스 이후의 데이터를 한칸씩 이동 O(n/2) -> O(n) 
- 연결 리스트: 추가나 삭제할 위치는 찾는데 O(n/2), 노드를 변경하는데 O(1) -> O(n)

#### 뒤에 추가(삭제)
- 배열 리스트: 추가나 삭제할 위치는 찾는데 O(1), 이동할 데이터 없음 -> O(1)
- 연결 리스트: 추가나 삭제할 위치는 찾는데 O(n), 노드를 변경하는데 O(1) -> O(n)

#### 인덱스 조회
- 배열 리스트: 배열에 인덱스를 사용 -> O(1) 
- 연결 리스트: 노드를 인덱스 수 만큼 이동해야함 -> O(n)

#### 검색
- 배열 리스트: 데이터를 찾을 때 까지 배열을 순회 -> O(n) 
- 연결 리스트: 데이터를 찾을 때 까지 노드를 순회 -> O(n)

#### 시간 복잡도와 실제 성능
이론적으로 MyLinkedList 가 평균 추가(중간 삽입)에 있어 더 효율적일 수 있지만, 현대 컴퓨터 시스템의 메모리 접근 패턴, CPU 캐시 최적화 등을 고려할 때 MyArrayList 가 실제 사용 환경에서 더 나은 성능을 보여주는 경우가 많다.
이런 이유로 실무에서는 주로 배열 리스트를 기본으로 사용한다.


### 5. 자바 리스트
#### List 자료 구조
`리스트란 순서를 유지하며 중복을 허용하는 자바 컬렉션 프레임워크의 대표적인 자료 구조이다.`

![컬렉션 프레임워크-리스트](https://github.com/user-attachments/assets/fc71c4fe-fb4e-430b-af61-d201b34a40c6)

- Collection 인터페이스   
Collection 인터페이스는 java.util 패키지의 컬렉션 프레임워크의 핵심 인터페이스 중 하나이다.

- List 인터페이스  
List 는 객체들의 순서가 있는 컬렉션을 나타내며, 같은 객체의 중복 저장을 허용한다.   
List 는 배열과 비슷하지만, 크기가 동적으로 변화하는 컬렉션을 다룰 때 유연하게 사용할 수 있다.

#### 자바 ArrayList
- 배열을 사용해서 데이터를 관리한다.
- 기본 CAPACITY 는 10이고 CAPACITY 를 초과하면 배열을 50% 증가한다.
- 메모리 고속 복사 연산을 사용한다.
  - ArrayList 의 중간 위치에 데이터를 추가하면, 추가할 위치 이후의 모든 요소를 한 칸씩 뒤로 이동시켜야 하는데 최적화된 메모리 고속 복사 연산을 사용해서 비교적 빠르게 수행된다.

#### 자바 LinkedList
- 이중 연결 리스트 구조로 다음 노드 뿐만 아니라 이전 노드로도 이동할 수 있다.
- 첫 번째 노드와 마지막 노드 둘다 참조한다.

![연결리스트](https://github.com/user-attachments/assets/548f22f0-e1ae-4e5b-a3d4-d9579a57cac5)



### 6. 자바 리스트의 성능 비교
#### 자바가 제공하는 리스트의 성능 비교 표
|    기능     |배열리스트|연결리스트    |
|:---------:|:--:|:--:|
| 앞에 추가(삭제) |O(n)|O(1)|
| 평균 추가(삭제) |O(n)|O(n)|
| 뒤에 추가(삭제) |O(1)|O(1)|
|  인덱스 조회   |O(1)|O(n)|
|    검색     |O(n)|O(n)|


#### 추가, 삭제
- `배열 리스트`는 인덱스를 통해 추가나 삭제할 위치를 O(1)로 빠르게 찾지만, 추가나 삭제 이후에 데이터를 한칸씩 밀어야 한다. 이 부분이 O(n)으로 오래 걸린다.
- `연결 리스트`는 인덱스를 통해 추가나 삭제할 위치를 O(n)으로 느리게 찾지만, 실제 데이터의 추가는 간단한 참조 변경으로 빠르게 O(1)로 수행된다.

#### 앞에 추가(삭제)
- 배열 리스트: 추가나 삭제할 위치는 찾는데 O(1), 데이터를 한칸씩 이동 O(n) -> O(n)
- 연결 리스트: 추가나 삭제할 위치는 찾는데 O(1), 노드를 변경하는데 O(1) -> O(1)

#### 평균 추가(삭제)
- 배열 리스트: 추가나 삭제할 위치는 찾는데 O(1), 인덱스 이후의 데이터를 한칸씩 이동 O(n/2) -> O(n)
- 연결 리스트: 추가나 삭제할 위치는 찾는데 O(n/2), 노드를 변경하는데 O(1) -> O(n)

#### 뒤에 추가(삭제)
- 배열 리스트: 추가나 삭제할 위치는 찾는데 O(1), 이동할 데이터 없음 -> O(1)
- 연결 리스트: 추가나 삭제할 위치는 찾는데 O(1), 노드를 변경하는데 O(1) -> O(1)
  - 참고로 자바가 제공하는 연결 리스트는 마지막 위치를 가지고 있다.

#### 인덱스 조회
- 배열 리스트: 배열에 인덱스를 사용 -> O(1)
- 연결 리스트: 노드를 인덱스 수 만큼 이동해야함 -> O(n)

#### 검색
- 배열 리스트: 데이터를 찾을 때 까지 배열을 순회 -> O(n)
- 연결 리스트: 데이터를 찾을 때 까지 노드를 순회 -> O(n)

#### 시간 복잡도와 실제 성능
이론적으로 LinkedList 가 중간 삽입에 있어 더 효율적일 수 있지만, 현대 컴퓨터 시스템의 메모리 접근 패턴,CPU 캐시 최적화,메모리 고속 복사 등을 고려할 때 ArrayList 가 실제 사용 환경에서 더 나은 성능을 보여주는 경우가 많다.  
ArrayList 는 요소들이 메모리 상에서 연속적으로 위치하여 CPU 캐시 효율이 좋고, 메모리 접근 속도가 빠르다.  
이런 이유로 실무에서는 주로 배열 리스트를 기본으로 사용한다.


### 메모
- 시간 계산
```java
long startTime = System.currentTimeMillis();
// 작업 코드
long endTime = System.currentTimeMillis();
System.out.println("크기: " + size + ", 계산 시간: " + (endTime - startTime) + "ms");

```


- return, break